public class Main {    private static Point pointX = new Point(1, 1);    private static Point pointY = new Point(1, 1);    private static Vector vector = new Vector();    public static void main(String[] args) {        double eps = 0.000001;        double[][] D_matrix = Optimization.get_E();        int k = 0, j = 0;        Optimization.Powell(D_matrix, pointX, pointY, vector, eps, k, j);        System.out.println(Optimization.counter + " " + Function.counter_func);        System.out.format("Minimum of the function = %.8f at the point = (%.8f, %.8f)%n", pointX.value, pointX.x1, pointX.x2);    }}class Optimization {    static int counter = 0;    private static double[][] mPlusmMinusm(double[][] A,                                           double[][] B,                                           double[][] C) {        double[][] sum = new double[2][2];        for (int i = 0 ; i < A.length ; i++) {            for (int j = 0 ; j < A[0].length ; j++) {                sum[i][j] = A[i][j] + B[i][j] - C[i][j];            }        }        return sum;    }    private static double[][] create_new_D_matrix(double[][] D_matrix,                                                  double[] q,                                                  double[] p) {        double[][] up = new double[2][2];        double down = 0;        for (int i = 0 ; i < p.length ; i++) {            for (int l = 0 ; l < p.length ; l++) {                up[i][l] = p[i] * p[l];            }        }        for (int i = 0 ; i < p.length ; i++) {            down += p[i] * q[i];        }        for (int i = 0 ; i < p.length ; i++) {            for (int l = 0 ; l < p.length ; l++) {                up[i][l] = up[i][l] / down;            }        }        double[][] up1 = new double[2][2];        double down1 = 0;        double[] test = {0, 0};        for (int i = 0 ; i < D_matrix.length ; i++) {            for (int l = 0 ; l < D_matrix[0].length ; l++) {                test[i] += D_matrix[i][l] * q[l];            }        }        for (int i = 0 ; i < test.length ; i++) {            for (int l = 0 ; l < q.length ; l++) {                up1[i][l] = test[i] * q[l];            }        }        up1 = Optimization.multiplicar(up1, D_matrix);        double[] test1 = {0, 0};        for (int i = 0 ; i < D_matrix.length ; i++) {            for (int l = 0 ; l < D_matrix[0].length ; l++) {                test1[i] += q[l] * D_matrix[l][i];            }        }        for (int i = 0 ; i < p.length ; i++) {            down1 += test1[i] * q[i];        }        for (int i = 0 ; i < p.length ; i++) {            for (int l = 0 ; l < p.length ; l++) {                up1[i][l] = up1[i][l] / down1;            }        }        return Optimization.mPlusmMinusm(D_matrix, up, up1);    }    private static void show_matrix(double[][] matrix) {        for (int i = 0 ; i < matrix.length ; i++) {            for (int j = 0 ; j < matrix[i].length ; j++) {                System.out.print(String.format("%.2f ", matrix[i][j]));            }            System.out.println();        }        System.out.println();    }    private static void show_vector(Vector vector) {        System.out.print(vector.valueX + " " + vector.valueY);        System.out.println();    }    private static double[][] multiplicar(double[][] A,                                          double[][] B) {        int aRows = A.length;        int aColumns = A[0].length;        int bRows = B.length;        int bColumns = B[0].length;        if (aColumns != bRows) {            throw new IllegalArgumentException("A:Rows: " + aColumns + " did not match B:Columns " + bRows + ".");        }        double[][] C = new double[aRows][bColumns];        for (int i = 0 ; i < aRows ; i++) {            for (int j = 0 ; j < bColumns ; j++) {                C[i][j] = 0.00000;            }        }        for (int i = 0 ; i < aRows ; i++) { // aRow            for (int j = 0 ; j < bColumns ; j++) { // bColumn                for (int k = 0 ; k < aColumns ; k++) { // aColumn                    C[i][j] += A[i][k] * B[k][j];                }            }        }        return C;    }    private static double leftEdgeOfInterval(Point point,                                             Vector vector) {        double step = 0.001;        double prevStep = 0;        int i = 0;        while (Function.func(point, vector, step) <= Function.func(point, vector, prevStep)) {            prevStep = step;            step += 0.1;            i++;        }        System.out.println();        return step;    }    static double[][] get_E() {        double[][] D_matrix = {{1, 0}, {0, 1}};        return D_matrix;    }    static void Powell(double[][] D_matrix,                       Point point_x,                       Point point_y,                       Vector vector,                       double eps,                       int k_x,                       int j_y) {        Function.gradient(point_y, vector);        if (Function.checkForOptimum(point_y, vector, eps))            return;        Vector d_direction = create_d(D_matrix, vector);        Function.func(point_y, vector, 0);        double a = 0;        double b = leftEdgeOfInterval(point_y, d_direction);        PointX minPoint = new PointX(a, a, b, Function.func(point_y, vector, a));        PointX y = new PointX(a, Function.func(point_y, d_direction, a));        PointX z = new PointX(b, Function.func(point_y, d_direction, b));        double step = dihot(point_y, d_direction, minPoint, y, z, eps, eps / 100);        //System.out.format("Step = %.2f%n", step);        point_y.x1 = point_y.x1 + step * d_direction.valueX;        point_y.x2 = point_y.x2 + step * d_direction.valueY;        if (j_y < 1) {            Vector new_vector = new Vector();            Function.gradient(point_y, new_vector);            double[] p = new double[2];            p[0] = step * d_direction.valueX;            p[1] = step * d_direction.valueY;            double[] q = new double[2];            q[0] = new_vector.valueX - vector.valueX;            q[1] = new_vector.valueY - vector.valueY;            D_matrix = create_new_D_matrix(D_matrix, q, p);            j_y++;            counter++;            Powell(D_matrix,                    point_x,                    point_y,                    vector,                    eps,                    k_x,                    j_y);        } else {            j_y = 0;            k_x++;            point_x.x1 = point_y.x1;            point_x.x2 = point_y.x2;            Function.func(point_x, vector, 0);            D_matrix = get_E();            counter++;            //if (counter == 0 || counter == 2 || counter == 3) {                System.out.println(counter);                System.out.format("-gradient = (%.3f, %.3f)%n", vector.valueX, vector.valueY);                System.out.format("direction = (%.3f, %.3f)%n", d_direction.valueX, d_direction.valueY);            //}            Powell(D_matrix,                    point_x,                    point_y,                    vector,                    eps,                    k_x,                    j_y);        }    }    private static Vector create_d(double[][] D_matrix,                                   Vector vector) {        Vector d_direction = new Vector();        for (int i = 0 ; i < D_matrix.length ; i++) {            double res = 0;            res += D_matrix[i][0] * vector.valueX;            res += D_matrix[i][1] * vector.valueY;            if (i == 0)                d_direction.valueX = -res;            else                d_direction.valueY = -res;        }        return d_direction;    }    private static double dihot(Point point,                                Vector vector,                                PointX minPoint,                                PointX y,                                PointX z,                                double eps,                                double a) {        double length;        y.x = (minPoint.previous + minPoint.next - a) / 2;        y.value = Function.func(point, vector, y.x);        z.x = (minPoint.previous + minPoint.next + a) / 2;        z.value = Function.func(point, vector, z.x);        if (y.value <= z.value)            minPoint.next = z.x;        else            minPoint.previous = y.x;        length = Math.abs(minPoint.next - minPoint.previous);        if (length < eps) {            minPoint.x = (minPoint.next + minPoint.previous) / 2;            minPoint.value = Function.func(point, vector, minPoint.x);            return minPoint.x;        }        dihot(point, vector, minPoint, y, z, eps, a);        return minPoint.x;    }}class Function {    static int counter_func = 0;    static double func(Point point,                       Vector vector,                       double step) {        counter_func++;        point.value = Math.pow(point.x1 + step * vector.valueX, 2) + 2 * Math.pow(point.x2 + step * vector.valueY, 2) - (point.x1 + step * vector.valueX) + 2 * (point.x2 + step * vector.valueY) + Math.exp(Math.pow(point.x1 + step * vector.valueX, 2) + Math.pow(point.x2 + step * vector.valueY, 2));        return point.value;    }    static void gradient(Point point,                         Vector vector) {        vector.valueX = 2 * point.x1 - 1 + 2 * point.x1 * Math.exp(Math.pow(point.x1, 2) + Math.pow(point.x2, 2));        vector.valueY = 4 * point.x2 + 2 + 2 * point.x2 * Math.exp(Math.pow(point.x1, 2) + Math.pow(point.x2, 2));    }    private static double sqrNorm(Point point,                                  Vector vector) {        return Math.pow(vector.valueX, 2) + Math.pow(vector.valueY, 2);    }    static boolean checkForOptimum(Point point,                                   Vector vector,                                   double eps) {        return sqrNorm(point, vector) < eps ? true : false;    }}class PointX {    double previous;    double next;    double x;    double value;    PointX(double x, double value) {        this.x = x;        this.value = value;    }    PointX(double previous, double x, double next, double value) {        this.x = x;        this.next = next;        this.previous = previous;        this.value = value;    }}class Point {    double previous;    double next;    double x1;    double x2;    double value;    Point(double x1, double x2) {        this.x1 = x1;        this.x2 = x2;    }    Point(double x1, double x2, double value) {        this.x1 = x1;        this.x2 = x2;        this.value = value;    }}class Vector {    double valueX;    double valueY;}